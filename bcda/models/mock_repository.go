// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package models

import (
	"context"
	"time"

	"github.com/CMSgov/bcda-app/optout"
	"github.com/pborman/uuid"
	mock "github.com/stretchr/testify/mock"
)

// NewMockRepository creates a new instance of MockRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRepository {
	mock := &MockRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRepository is an autogenerated mock type for the Repository type
type MockRepository struct {
	mock.Mock
}

type MockRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRepository) EXPECT() *MockRepository_Expecter {
	return &MockRepository_Expecter{mock: &_m.Mock}
}

// CreateACO provides a mock function for the type MockRepository
func (_mock *MockRepository) CreateACO(ctx context.Context, aco ACO) error {
	ret := _mock.Called(ctx, aco)

	if len(ret) == 0 {
		panic("no return value specified for CreateACO")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ACO) error); ok {
		r0 = returnFunc(ctx, aco)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_CreateACO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateACO'
type MockRepository_CreateACO_Call struct {
	*mock.Call
}

// CreateACO is a helper method to define mock.On call
//   - ctx context.Context
//   - aco ACO
func (_e *MockRepository_Expecter) CreateACO(ctx interface{}, aco interface{}) *MockRepository_CreateACO_Call {
	return &MockRepository_CreateACO_Call{Call: _e.mock.On("CreateACO", ctx, aco)}
}

func (_c *MockRepository_CreateACO_Call) Run(run func(ctx context.Context, aco ACO)) *MockRepository_CreateACO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 ACO
		if args[1] != nil {
			arg1 = args[1].(ACO)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_CreateACO_Call) Return(err error) *MockRepository_CreateACO_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_CreateACO_Call) RunAndReturn(run func(ctx context.Context, aco ACO) error) *MockRepository_CreateACO_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCCLFFile provides a mock function for the type MockRepository
func (_mock *MockRepository) CreateCCLFFile(ctx context.Context, cclfFile CCLFFile) (uint, error) {
	ret := _mock.Called(ctx, cclfFile)

	if len(ret) == 0 {
		panic("no return value specified for CreateCCLFFile")
	}

	var r0 uint
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, CCLFFile) (uint, error)); ok {
		return returnFunc(ctx, cclfFile)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, CCLFFile) uint); ok {
		r0 = returnFunc(ctx, cclfFile)
	} else {
		r0 = ret.Get(0).(uint)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, CCLFFile) error); ok {
		r1 = returnFunc(ctx, cclfFile)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_CreateCCLFFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCCLFFile'
type MockRepository_CreateCCLFFile_Call struct {
	*mock.Call
}

// CreateCCLFFile is a helper method to define mock.On call
//   - ctx context.Context
//   - cclfFile CCLFFile
func (_e *MockRepository_Expecter) CreateCCLFFile(ctx interface{}, cclfFile interface{}) *MockRepository_CreateCCLFFile_Call {
	return &MockRepository_CreateCCLFFile_Call{Call: _e.mock.On("CreateCCLFFile", ctx, cclfFile)}
}

func (_c *MockRepository_CreateCCLFFile_Call) Run(run func(ctx context.Context, cclfFile CCLFFile)) *MockRepository_CreateCCLFFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 CCLFFile
		if args[1] != nil {
			arg1 = args[1].(CCLFFile)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_CreateCCLFFile_Call) Return(v uint, err error) *MockRepository_CreateCCLFFile_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockRepository_CreateCCLFFile_Call) RunAndReturn(run func(ctx context.Context, cclfFile CCLFFile) (uint, error)) *MockRepository_CreateCCLFFile_Call {
	_c.Call.Return(run)
	return _c
}

// CreateJob provides a mock function for the type MockRepository
func (_mock *MockRepository) CreateJob(ctx context.Context, j Job) (uint, error) {
	ret := _mock.Called(ctx, j)

	if len(ret) == 0 {
		panic("no return value specified for CreateJob")
	}

	var r0 uint
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, Job) (uint, error)); ok {
		return returnFunc(ctx, j)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, Job) uint); ok {
		r0 = returnFunc(ctx, j)
	} else {
		r0 = ret.Get(0).(uint)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, Job) error); ok {
		r1 = returnFunc(ctx, j)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_CreateJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateJob'
type MockRepository_CreateJob_Call struct {
	*mock.Call
}

// CreateJob is a helper method to define mock.On call
//   - ctx context.Context
//   - j Job
func (_e *MockRepository_Expecter) CreateJob(ctx interface{}, j interface{}) *MockRepository_CreateJob_Call {
	return &MockRepository_CreateJob_Call{Call: _e.mock.On("CreateJob", ctx, j)}
}

func (_c *MockRepository_CreateJob_Call) Run(run func(ctx context.Context, j Job)) *MockRepository_CreateJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 Job
		if args[1] != nil {
			arg1 = args[1].(Job)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_CreateJob_Call) Return(jobID uint, err error) *MockRepository_CreateJob_Call {
	_c.Call.Return(jobID, err)
	return _c
}

func (_c *MockRepository_CreateJob_Call) RunAndReturn(run func(ctx context.Context, j Job) (uint, error)) *MockRepository_CreateJob_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSuppression provides a mock function for the type MockRepository
func (_mock *MockRepository) CreateSuppression(ctx context.Context, suppression optout.OptOutRecord) error {
	ret := _mock.Called(ctx, suppression)

	if len(ret) == 0 {
		panic("no return value specified for CreateSuppression")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, optout.OptOutRecord) error); ok {
		r0 = returnFunc(ctx, suppression)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_CreateSuppression_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSuppression'
type MockRepository_CreateSuppression_Call struct {
	*mock.Call
}

// CreateSuppression is a helper method to define mock.On call
//   - ctx context.Context
//   - suppression optout.OptOutRecord
func (_e *MockRepository_Expecter) CreateSuppression(ctx interface{}, suppression interface{}) *MockRepository_CreateSuppression_Call {
	return &MockRepository_CreateSuppression_Call{Call: _e.mock.On("CreateSuppression", ctx, suppression)}
}

func (_c *MockRepository_CreateSuppression_Call) Run(run func(ctx context.Context, suppression optout.OptOutRecord)) *MockRepository_CreateSuppression_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 optout.OptOutRecord
		if args[1] != nil {
			arg1 = args[1].(optout.OptOutRecord)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_CreateSuppression_Call) Return(err error) *MockRepository_CreateSuppression_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_CreateSuppression_Call) RunAndReturn(run func(ctx context.Context, suppression optout.OptOutRecord) error) *MockRepository_CreateSuppression_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSuppressionFile provides a mock function for the type MockRepository
func (_mock *MockRepository) CreateSuppressionFile(ctx context.Context, suppressionFile optout.OptOutFile) (uint, error) {
	ret := _mock.Called(ctx, suppressionFile)

	if len(ret) == 0 {
		panic("no return value specified for CreateSuppressionFile")
	}

	var r0 uint
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, optout.OptOutFile) (uint, error)); ok {
		return returnFunc(ctx, suppressionFile)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, optout.OptOutFile) uint); ok {
		r0 = returnFunc(ctx, suppressionFile)
	} else {
		r0 = ret.Get(0).(uint)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, optout.OptOutFile) error); ok {
		r1 = returnFunc(ctx, suppressionFile)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_CreateSuppressionFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSuppressionFile'
type MockRepository_CreateSuppressionFile_Call struct {
	*mock.Call
}

// CreateSuppressionFile is a helper method to define mock.On call
//   - ctx context.Context
//   - suppressionFile optout.OptOutFile
func (_e *MockRepository_Expecter) CreateSuppressionFile(ctx interface{}, suppressionFile interface{}) *MockRepository_CreateSuppressionFile_Call {
	return &MockRepository_CreateSuppressionFile_Call{Call: _e.mock.On("CreateSuppressionFile", ctx, suppressionFile)}
}

func (_c *MockRepository_CreateSuppressionFile_Call) Run(run func(ctx context.Context, suppressionFile optout.OptOutFile)) *MockRepository_CreateSuppressionFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 optout.OptOutFile
		if args[1] != nil {
			arg1 = args[1].(optout.OptOutFile)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_CreateSuppressionFile_Call) Return(v uint, err error) *MockRepository_CreateSuppressionFile_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockRepository_CreateSuppressionFile_Call) RunAndReturn(run func(ctx context.Context, suppressionFile optout.OptOutFile) (uint, error)) *MockRepository_CreateSuppressionFile_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCCLFFile provides a mock function for the type MockRepository
func (_mock *MockRepository) DeleteCCLFFile(ctx context.Context, fileID uint) error {
	ret := _mock.Called(ctx, fileID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCCLFFile")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) error); ok {
		r0 = returnFunc(ctx, fileID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_DeleteCCLFFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCCLFFile'
type MockRepository_DeleteCCLFFile_Call struct {
	*mock.Call
}

// DeleteCCLFFile is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID uint
func (_e *MockRepository_Expecter) DeleteCCLFFile(ctx interface{}, fileID interface{}) *MockRepository_DeleteCCLFFile_Call {
	return &MockRepository_DeleteCCLFFile_Call{Call: _e.mock.On("DeleteCCLFFile", ctx, fileID)}
}

func (_c *MockRepository_DeleteCCLFFile_Call) Run(run func(ctx context.Context, fileID uint)) *MockRepository_DeleteCCLFFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint
		if args[1] != nil {
			arg1 = args[1].(uint)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_DeleteCCLFFile_Call) Return(err error) *MockRepository_DeleteCCLFFile_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_DeleteCCLFFile_Call) RunAndReturn(run func(ctx context.Context, fileID uint) error) *MockRepository_DeleteCCLFFile_Call {
	_c.Call.Return(run)
	return _c
}

// GetACOByCMSID provides a mock function for the type MockRepository
func (_mock *MockRepository) GetACOByCMSID(ctx context.Context, cmsID string) (*ACO, error) {
	ret := _mock.Called(ctx, cmsID)

	if len(ret) == 0 {
		panic("no return value specified for GetACOByCMSID")
	}

	var r0 *ACO
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*ACO, error)); ok {
		return returnFunc(ctx, cmsID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *ACO); ok {
		r0 = returnFunc(ctx, cmsID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ACO)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, cmsID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetACOByCMSID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetACOByCMSID'
type MockRepository_GetACOByCMSID_Call struct {
	*mock.Call
}

// GetACOByCMSID is a helper method to define mock.On call
//   - ctx context.Context
//   - cmsID string
func (_e *MockRepository_Expecter) GetACOByCMSID(ctx interface{}, cmsID interface{}) *MockRepository_GetACOByCMSID_Call {
	return &MockRepository_GetACOByCMSID_Call{Call: _e.mock.On("GetACOByCMSID", ctx, cmsID)}
}

func (_c *MockRepository_GetACOByCMSID_Call) Run(run func(ctx context.Context, cmsID string)) *MockRepository_GetACOByCMSID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_GetACOByCMSID_Call) Return(aCO *ACO, err error) *MockRepository_GetACOByCMSID_Call {
	_c.Call.Return(aCO, err)
	return _c
}

func (_c *MockRepository_GetACOByCMSID_Call) RunAndReturn(run func(ctx context.Context, cmsID string) (*ACO, error)) *MockRepository_GetACOByCMSID_Call {
	_c.Call.Return(run)
	return _c
}

// GetACOByClientID provides a mock function for the type MockRepository
func (_mock *MockRepository) GetACOByClientID(ctx context.Context, clientID string) (*ACO, error) {
	ret := _mock.Called(ctx, clientID)

	if len(ret) == 0 {
		panic("no return value specified for GetACOByClientID")
	}

	var r0 *ACO
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*ACO, error)); ok {
		return returnFunc(ctx, clientID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *ACO); ok {
		r0 = returnFunc(ctx, clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ACO)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, clientID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetACOByClientID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetACOByClientID'
type MockRepository_GetACOByClientID_Call struct {
	*mock.Call
}

// GetACOByClientID is a helper method to define mock.On call
//   - ctx context.Context
//   - clientID string
func (_e *MockRepository_Expecter) GetACOByClientID(ctx interface{}, clientID interface{}) *MockRepository_GetACOByClientID_Call {
	return &MockRepository_GetACOByClientID_Call{Call: _e.mock.On("GetACOByClientID", ctx, clientID)}
}

func (_c *MockRepository_GetACOByClientID_Call) Run(run func(ctx context.Context, clientID string)) *MockRepository_GetACOByClientID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_GetACOByClientID_Call) Return(aCO *ACO, err error) *MockRepository_GetACOByClientID_Call {
	_c.Call.Return(aCO, err)
	return _c
}

func (_c *MockRepository_GetACOByClientID_Call) RunAndReturn(run func(ctx context.Context, clientID string) (*ACO, error)) *MockRepository_GetACOByClientID_Call {
	_c.Call.Return(run)
	return _c
}

// GetACOByUUID provides a mock function for the type MockRepository
func (_mock *MockRepository) GetACOByUUID(ctx context.Context, uuid1 uuid.UUID) (*ACO, error) {
	ret := _mock.Called(ctx, uuid1)

	if len(ret) == 0 {
		panic("no return value specified for GetACOByUUID")
	}

	var r0 *ACO
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*ACO, error)); ok {
		return returnFunc(ctx, uuid1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *ACO); ok {
		r0 = returnFunc(ctx, uuid1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ACO)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, uuid1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetACOByUUID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetACOByUUID'
type MockRepository_GetACOByUUID_Call struct {
	*mock.Call
}

// GetACOByUUID is a helper method to define mock.On call
//   - ctx context.Context
//   - uuid1 uuid.UUID
func (_e *MockRepository_Expecter) GetACOByUUID(ctx interface{}, uuid1 interface{}) *MockRepository_GetACOByUUID_Call {
	return &MockRepository_GetACOByUUID_Call{Call: _e.mock.On("GetACOByUUID", ctx, uuid1)}
}

func (_c *MockRepository_GetACOByUUID_Call) Run(run func(ctx context.Context, uuid1 uuid.UUID)) *MockRepository_GetACOByUUID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_GetACOByUUID_Call) Return(aCO *ACO, err error) *MockRepository_GetACOByUUID_Call {
	_c.Call.Return(aCO, err)
	return _c
}

func (_c *MockRepository_GetACOByUUID_Call) RunAndReturn(run func(ctx context.Context, uuid1 uuid.UUID) (*ACO, error)) *MockRepository_GetACOByUUID_Call {
	_c.Call.Return(run)
	return _c
}

// GetCCLFBeneficiaries provides a mock function for the type MockRepository
func (_mock *MockRepository) GetCCLFBeneficiaries(ctx context.Context, cclfFileID uint, ignoredMBIs []string) ([]*CCLFBeneficiary, error) {
	ret := _mock.Called(ctx, cclfFileID, ignoredMBIs)

	if len(ret) == 0 {
		panic("no return value specified for GetCCLFBeneficiaries")
	}

	var r0 []*CCLFBeneficiary
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint, []string) ([]*CCLFBeneficiary, error)); ok {
		return returnFunc(ctx, cclfFileID, ignoredMBIs)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint, []string) []*CCLFBeneficiary); ok {
		r0 = returnFunc(ctx, cclfFileID, ignoredMBIs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*CCLFBeneficiary)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint, []string) error); ok {
		r1 = returnFunc(ctx, cclfFileID, ignoredMBIs)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetCCLFBeneficiaries_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCCLFBeneficiaries'
type MockRepository_GetCCLFBeneficiaries_Call struct {
	*mock.Call
}

// GetCCLFBeneficiaries is a helper method to define mock.On call
//   - ctx context.Context
//   - cclfFileID uint
//   - ignoredMBIs []string
func (_e *MockRepository_Expecter) GetCCLFBeneficiaries(ctx interface{}, cclfFileID interface{}, ignoredMBIs interface{}) *MockRepository_GetCCLFBeneficiaries_Call {
	return &MockRepository_GetCCLFBeneficiaries_Call{Call: _e.mock.On("GetCCLFBeneficiaries", ctx, cclfFileID, ignoredMBIs)}
}

func (_c *MockRepository_GetCCLFBeneficiaries_Call) Run(run func(ctx context.Context, cclfFileID uint, ignoredMBIs []string)) *MockRepository_GetCCLFBeneficiaries_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint
		if args[1] != nil {
			arg1 = args[1].(uint)
		}
		var arg2 []string
		if args[2] != nil {
			arg2 = args[2].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_GetCCLFBeneficiaries_Call) Return(cCLFBeneficiarys []*CCLFBeneficiary, err error) *MockRepository_GetCCLFBeneficiaries_Call {
	_c.Call.Return(cCLFBeneficiarys, err)
	return _c
}

func (_c *MockRepository_GetCCLFBeneficiaries_Call) RunAndReturn(run func(ctx context.Context, cclfFileID uint, ignoredMBIs []string) ([]*CCLFBeneficiary, error)) *MockRepository_GetCCLFBeneficiaries_Call {
	_c.Call.Return(run)
	return _c
}

// GetCCLFBeneficiaryMBIs provides a mock function for the type MockRepository
func (_mock *MockRepository) GetCCLFBeneficiaryMBIs(ctx context.Context, cclfFileID uint) ([]string, error) {
	ret := _mock.Called(ctx, cclfFileID)

	if len(ret) == 0 {
		panic("no return value specified for GetCCLFBeneficiaryMBIs")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) ([]string, error)); ok {
		return returnFunc(ctx, cclfFileID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) []string); ok {
		r0 = returnFunc(ctx, cclfFileID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = returnFunc(ctx, cclfFileID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetCCLFBeneficiaryMBIs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCCLFBeneficiaryMBIs'
type MockRepository_GetCCLFBeneficiaryMBIs_Call struct {
	*mock.Call
}

// GetCCLFBeneficiaryMBIs is a helper method to define mock.On call
//   - ctx context.Context
//   - cclfFileID uint
func (_e *MockRepository_Expecter) GetCCLFBeneficiaryMBIs(ctx interface{}, cclfFileID interface{}) *MockRepository_GetCCLFBeneficiaryMBIs_Call {
	return &MockRepository_GetCCLFBeneficiaryMBIs_Call{Call: _e.mock.On("GetCCLFBeneficiaryMBIs", ctx, cclfFileID)}
}

func (_c *MockRepository_GetCCLFBeneficiaryMBIs_Call) Run(run func(ctx context.Context, cclfFileID uint)) *MockRepository_GetCCLFBeneficiaryMBIs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint
		if args[1] != nil {
			arg1 = args[1].(uint)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_GetCCLFBeneficiaryMBIs_Call) Return(strings []string, err error) *MockRepository_GetCCLFBeneficiaryMBIs_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *MockRepository_GetCCLFBeneficiaryMBIs_Call) RunAndReturn(run func(ctx context.Context, cclfFileID uint) ([]string, error)) *MockRepository_GetCCLFBeneficiaryMBIs_Call {
	_c.Call.Return(run)
	return _c
}

// GetCCLFFileByID provides a mock function for the type MockRepository
func (_mock *MockRepository) GetCCLFFileByID(ctx context.Context, ID uint) (*CCLFFile, error) {
	ret := _mock.Called(ctx, ID)

	if len(ret) == 0 {
		panic("no return value specified for GetCCLFFileByID")
	}

	var r0 *CCLFFile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) (*CCLFFile, error)); ok {
		return returnFunc(ctx, ID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) *CCLFFile); ok {
		r0 = returnFunc(ctx, ID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*CCLFFile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = returnFunc(ctx, ID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetCCLFFileByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCCLFFileByID'
type MockRepository_GetCCLFFileByID_Call struct {
	*mock.Call
}

// GetCCLFFileByID is a helper method to define mock.On call
//   - ctx context.Context
//   - ID uint
func (_e *MockRepository_Expecter) GetCCLFFileByID(ctx interface{}, ID interface{}) *MockRepository_GetCCLFFileByID_Call {
	return &MockRepository_GetCCLFFileByID_Call{Call: _e.mock.On("GetCCLFFileByID", ctx, ID)}
}

func (_c *MockRepository_GetCCLFFileByID_Call) Run(run func(ctx context.Context, ID uint)) *MockRepository_GetCCLFFileByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint
		if args[1] != nil {
			arg1 = args[1].(uint)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_GetCCLFFileByID_Call) Return(cCLFFile *CCLFFile, err error) *MockRepository_GetCCLFFileByID_Call {
	_c.Call.Return(cCLFFile, err)
	return _c
}

func (_c *MockRepository_GetCCLFFileByID_Call) RunAndReturn(run func(ctx context.Context, ID uint) (*CCLFFile, error)) *MockRepository_GetCCLFFileByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetCCLFFileExistsByName provides a mock function for the type MockRepository
func (_mock *MockRepository) GetCCLFFileExistsByName(ctx context.Context, name string) (bool, error) {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetCCLFFileExistsByName")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return returnFunc(ctx, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = returnFunc(ctx, name)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetCCLFFileExistsByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCCLFFileExistsByName'
type MockRepository_GetCCLFFileExistsByName_Call struct {
	*mock.Call
}

// GetCCLFFileExistsByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockRepository_Expecter) GetCCLFFileExistsByName(ctx interface{}, name interface{}) *MockRepository_GetCCLFFileExistsByName_Call {
	return &MockRepository_GetCCLFFileExistsByName_Call{Call: _e.mock.On("GetCCLFFileExistsByName", ctx, name)}
}

func (_c *MockRepository_GetCCLFFileExistsByName_Call) Run(run func(ctx context.Context, name string)) *MockRepository_GetCCLFFileExistsByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_GetCCLFFileExistsByName_Call) Return(b bool, err error) *MockRepository_GetCCLFFileExistsByName_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockRepository_GetCCLFFileExistsByName_Call) RunAndReturn(run func(ctx context.Context, name string) (bool, error)) *MockRepository_GetCCLFFileExistsByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobByID provides a mock function for the type MockRepository
func (_mock *MockRepository) GetJobByID(ctx context.Context, jobID uint) (*Job, error) {
	ret := _mock.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobByID")
	}

	var r0 *Job
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) (*Job, error)); ok {
		return returnFunc(ctx, jobID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) *Job); ok {
		r0 = returnFunc(ctx, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Job)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = returnFunc(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetJobByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobByID'
type MockRepository_GetJobByID_Call struct {
	*mock.Call
}

// GetJobByID is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID uint
func (_e *MockRepository_Expecter) GetJobByID(ctx interface{}, jobID interface{}) *MockRepository_GetJobByID_Call {
	return &MockRepository_GetJobByID_Call{Call: _e.mock.On("GetJobByID", ctx, jobID)}
}

func (_c *MockRepository_GetJobByID_Call) Run(run func(ctx context.Context, jobID uint)) *MockRepository_GetJobByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint
		if args[1] != nil {
			arg1 = args[1].(uint)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_GetJobByID_Call) Return(job *Job, err error) *MockRepository_GetJobByID_Call {
	_c.Call.Return(job, err)
	return _c
}

func (_c *MockRepository_GetJobByID_Call) RunAndReturn(run func(ctx context.Context, jobID uint) (*Job, error)) *MockRepository_GetJobByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobKey provides a mock function for the type MockRepository
func (_mock *MockRepository) GetJobKey(ctx context.Context, jobID uint, filename string) (*JobKey, error) {
	ret := _mock.Called(ctx, jobID, filename)

	if len(ret) == 0 {
		panic("no return value specified for GetJobKey")
	}

	var r0 *JobKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint, string) (*JobKey, error)); ok {
		return returnFunc(ctx, jobID, filename)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint, string) *JobKey); ok {
		r0 = returnFunc(ctx, jobID, filename)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*JobKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint, string) error); ok {
		r1 = returnFunc(ctx, jobID, filename)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetJobKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobKey'
type MockRepository_GetJobKey_Call struct {
	*mock.Call
}

// GetJobKey is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID uint
//   - filename string
func (_e *MockRepository_Expecter) GetJobKey(ctx interface{}, jobID interface{}, filename interface{}) *MockRepository_GetJobKey_Call {
	return &MockRepository_GetJobKey_Call{Call: _e.mock.On("GetJobKey", ctx, jobID, filename)}
}

func (_c *MockRepository_GetJobKey_Call) Run(run func(ctx context.Context, jobID uint, filename string)) *MockRepository_GetJobKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint
		if args[1] != nil {
			arg1 = args[1].(uint)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_GetJobKey_Call) Return(jobKey *JobKey, err error) *MockRepository_GetJobKey_Call {
	_c.Call.Return(jobKey, err)
	return _c
}

func (_c *MockRepository_GetJobKey_Call) RunAndReturn(run func(ctx context.Context, jobID uint, filename string) (*JobKey, error)) *MockRepository_GetJobKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobKeys provides a mock function for the type MockRepository
func (_mock *MockRepository) GetJobKeys(ctx context.Context, jobID uint) ([]*JobKey, error) {
	ret := _mock.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobKeys")
	}

	var r0 []*JobKey
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) ([]*JobKey, error)); ok {
		return returnFunc(ctx, jobID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint) []*JobKey); ok {
		r0 = returnFunc(ctx, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*JobKey)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = returnFunc(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetJobKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobKeys'
type MockRepository_GetJobKeys_Call struct {
	*mock.Call
}

// GetJobKeys is a helper method to define mock.On call
//   - ctx context.Context
//   - jobID uint
func (_e *MockRepository_Expecter) GetJobKeys(ctx interface{}, jobID interface{}) *MockRepository_GetJobKeys_Call {
	return &MockRepository_GetJobKeys_Call{Call: _e.mock.On("GetJobKeys", ctx, jobID)}
}

func (_c *MockRepository_GetJobKeys_Call) Run(run func(ctx context.Context, jobID uint)) *MockRepository_GetJobKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint
		if args[1] != nil {
			arg1 = args[1].(uint)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_GetJobKeys_Call) Return(jobKeys []*JobKey, err error) *MockRepository_GetJobKeys_Call {
	_c.Call.Return(jobKeys, err)
	return _c
}

func (_c *MockRepository_GetJobKeys_Call) RunAndReturn(run func(ctx context.Context, jobID uint) ([]*JobKey, error)) *MockRepository_GetJobKeys_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobs provides a mock function for the type MockRepository
func (_mock *MockRepository) GetJobs(ctx context.Context, acoID uuid.UUID, statuses ...JobStatus) ([]*Job, error) {
	var tmpRet mock.Arguments
	if len(statuses) > 0 {
		tmpRet = _mock.Called(ctx, acoID, statuses)
	} else {
		tmpRet = _mock.Called(ctx, acoID)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetJobs")
	}

	var r0 []*Job
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...JobStatus) ([]*Job, error)); ok {
		return returnFunc(ctx, acoID, statuses...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, ...JobStatus) []*Job); ok {
		r0 = returnFunc(ctx, acoID, statuses...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Job)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, ...JobStatus) error); ok {
		r1 = returnFunc(ctx, acoID, statuses...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobs'
type MockRepository_GetJobs_Call struct {
	*mock.Call
}

// GetJobs is a helper method to define mock.On call
//   - ctx context.Context
//   - acoID uuid.UUID
//   - statuses ...JobStatus
func (_e *MockRepository_Expecter) GetJobs(ctx interface{}, acoID interface{}, statuses ...interface{}) *MockRepository_GetJobs_Call {
	return &MockRepository_GetJobs_Call{Call: _e.mock.On("GetJobs",
		append([]interface{}{ctx, acoID}, statuses...)...)}
}

func (_c *MockRepository_GetJobs_Call) Run(run func(ctx context.Context, acoID uuid.UUID, statuses ...JobStatus)) *MockRepository_GetJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 []JobStatus
		var variadicArgs []JobStatus
		if len(args) > 2 {
			variadicArgs = args[2].([]JobStatus)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockRepository_GetJobs_Call) Return(jobs []*Job, err error) *MockRepository_GetJobs_Call {
	_c.Call.Return(jobs, err)
	return _c
}

func (_c *MockRepository_GetJobs_Call) RunAndReturn(run func(ctx context.Context, acoID uuid.UUID, statuses ...JobStatus) ([]*Job, error)) *MockRepository_GetJobs_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobsByUpdateTimeAndStatus provides a mock function for the type MockRepository
func (_mock *MockRepository) GetJobsByUpdateTimeAndStatus(ctx context.Context, lowerBound time.Time, upperBound time.Time, statuses ...JobStatus) ([]*Job, error) {
	var tmpRet mock.Arguments
	if len(statuses) > 0 {
		tmpRet = _mock.Called(ctx, lowerBound, upperBound, statuses)
	} else {
		tmpRet = _mock.Called(ctx, lowerBound, upperBound)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetJobsByUpdateTimeAndStatus")
	}

	var r0 []*Job
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time, time.Time, ...JobStatus) ([]*Job, error)); ok {
		return returnFunc(ctx, lowerBound, upperBound, statuses...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time, time.Time, ...JobStatus) []*Job); ok {
		r0 = returnFunc(ctx, lowerBound, upperBound, statuses...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Job)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Time, time.Time, ...JobStatus) error); ok {
		r1 = returnFunc(ctx, lowerBound, upperBound, statuses...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetJobsByUpdateTimeAndStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobsByUpdateTimeAndStatus'
type MockRepository_GetJobsByUpdateTimeAndStatus_Call struct {
	*mock.Call
}

// GetJobsByUpdateTimeAndStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - lowerBound time.Time
//   - upperBound time.Time
//   - statuses ...JobStatus
func (_e *MockRepository_Expecter) GetJobsByUpdateTimeAndStatus(ctx interface{}, lowerBound interface{}, upperBound interface{}, statuses ...interface{}) *MockRepository_GetJobsByUpdateTimeAndStatus_Call {
	return &MockRepository_GetJobsByUpdateTimeAndStatus_Call{Call: _e.mock.On("GetJobsByUpdateTimeAndStatus",
		append([]interface{}{ctx, lowerBound, upperBound}, statuses...)...)}
}

func (_c *MockRepository_GetJobsByUpdateTimeAndStatus_Call) Run(run func(ctx context.Context, lowerBound time.Time, upperBound time.Time, statuses ...JobStatus)) *MockRepository_GetJobsByUpdateTimeAndStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		var arg3 []JobStatus
		var variadicArgs []JobStatus
		if len(args) > 3 {
			variadicArgs = args[3].([]JobStatus)
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *MockRepository_GetJobsByUpdateTimeAndStatus_Call) Return(jobs []*Job, err error) *MockRepository_GetJobsByUpdateTimeAndStatus_Call {
	_c.Call.Return(jobs, err)
	return _c
}

func (_c *MockRepository_GetJobsByUpdateTimeAndStatus_Call) RunAndReturn(run func(ctx context.Context, lowerBound time.Time, upperBound time.Time, statuses ...JobStatus) ([]*Job, error)) *MockRepository_GetJobsByUpdateTimeAndStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestCCLFFile provides a mock function for the type MockRepository
func (_mock *MockRepository) GetLatestCCLFFile(ctx context.Context, cmsID string, cclfNum int, importStatus string, lowerBound time.Time, upperBound time.Time, fileType CCLFFileType) (*CCLFFile, error) {
	ret := _mock.Called(ctx, cmsID, cclfNum, importStatus, lowerBound, upperBound, fileType)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestCCLFFile")
	}

	var r0 *CCLFFile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, string, time.Time, time.Time, CCLFFileType) (*CCLFFile, error)); ok {
		return returnFunc(ctx, cmsID, cclfNum, importStatus, lowerBound, upperBound, fileType)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int, string, time.Time, time.Time, CCLFFileType) *CCLFFile); ok {
		r0 = returnFunc(ctx, cmsID, cclfNum, importStatus, lowerBound, upperBound, fileType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*CCLFFile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int, string, time.Time, time.Time, CCLFFileType) error); ok {
		r1 = returnFunc(ctx, cmsID, cclfNum, importStatus, lowerBound, upperBound, fileType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetLatestCCLFFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestCCLFFile'
type MockRepository_GetLatestCCLFFile_Call struct {
	*mock.Call
}

// GetLatestCCLFFile is a helper method to define mock.On call
//   - ctx context.Context
//   - cmsID string
//   - cclfNum int
//   - importStatus string
//   - lowerBound time.Time
//   - upperBound time.Time
//   - fileType CCLFFileType
func (_e *MockRepository_Expecter) GetLatestCCLFFile(ctx interface{}, cmsID interface{}, cclfNum interface{}, importStatus interface{}, lowerBound interface{}, upperBound interface{}, fileType interface{}) *MockRepository_GetLatestCCLFFile_Call {
	return &MockRepository_GetLatestCCLFFile_Call{Call: _e.mock.On("GetLatestCCLFFile", ctx, cmsID, cclfNum, importStatus, lowerBound, upperBound, fileType)}
}

func (_c *MockRepository_GetLatestCCLFFile_Call) Run(run func(ctx context.Context, cmsID string, cclfNum int, importStatus string, lowerBound time.Time, upperBound time.Time, fileType CCLFFileType)) *MockRepository_GetLatestCCLFFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 string
		if args[3] != nil {
			arg3 = args[3].(string)
		}
		var arg4 time.Time
		if args[4] != nil {
			arg4 = args[4].(time.Time)
		}
		var arg5 time.Time
		if args[5] != nil {
			arg5 = args[5].(time.Time)
		}
		var arg6 CCLFFileType
		if args[6] != nil {
			arg6 = args[6].(CCLFFileType)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
		)
	})
	return _c
}

func (_c *MockRepository_GetLatestCCLFFile_Call) Return(cCLFFile *CCLFFile, err error) *MockRepository_GetLatestCCLFFile_Call {
	_c.Call.Return(cCLFFile, err)
	return _c
}

func (_c *MockRepository_GetLatestCCLFFile_Call) RunAndReturn(run func(ctx context.Context, cmsID string, cclfNum int, importStatus string, lowerBound time.Time, upperBound time.Time, fileType CCLFFileType) (*CCLFFile, error)) *MockRepository_GetLatestCCLFFile_Call {
	_c.Call.Return(run)
	return _c
}

// GetSuppressedMBIs provides a mock function for the type MockRepository
func (_mock *MockRepository) GetSuppressedMBIs(ctx context.Context, lookbackDays int, upperBound time.Time) ([]string, error) {
	ret := _mock.Called(ctx, lookbackDays, upperBound)

	if len(ret) == 0 {
		panic("no return value specified for GetSuppressedMBIs")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, time.Time) ([]string, error)); ok {
		return returnFunc(ctx, lookbackDays, upperBound)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, time.Time) []string); ok {
		r0 = returnFunc(ctx, lookbackDays, upperBound)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, time.Time) error); ok {
		r1 = returnFunc(ctx, lookbackDays, upperBound)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetSuppressedMBIs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSuppressedMBIs'
type MockRepository_GetSuppressedMBIs_Call struct {
	*mock.Call
}

// GetSuppressedMBIs is a helper method to define mock.On call
//   - ctx context.Context
//   - lookbackDays int
//   - upperBound time.Time
func (_e *MockRepository_Expecter) GetSuppressedMBIs(ctx interface{}, lookbackDays interface{}, upperBound interface{}) *MockRepository_GetSuppressedMBIs_Call {
	return &MockRepository_GetSuppressedMBIs_Call{Call: _e.mock.On("GetSuppressedMBIs", ctx, lookbackDays, upperBound)}
}

func (_c *MockRepository_GetSuppressedMBIs_Call) Run(run func(ctx context.Context, lookbackDays int, upperBound time.Time)) *MockRepository_GetSuppressedMBIs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_GetSuppressedMBIs_Call) Return(strings []string, err error) *MockRepository_GetSuppressedMBIs_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *MockRepository_GetSuppressedMBIs_Call) RunAndReturn(run func(ctx context.Context, lookbackDays int, upperBound time.Time) ([]string, error)) *MockRepository_GetSuppressedMBIs_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateACO provides a mock function for the type MockRepository
func (_mock *MockRepository) UpdateACO(ctx context.Context, acoUUID uuid.UUID, fieldsAndValues map[string]interface{}) error {
	ret := _mock.Called(ctx, acoUUID, fieldsAndValues)

	if len(ret) == 0 {
		panic("no return value specified for UpdateACO")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, map[string]interface{}) error); ok {
		r0 = returnFunc(ctx, acoUUID, fieldsAndValues)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_UpdateACO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateACO'
type MockRepository_UpdateACO_Call struct {
	*mock.Call
}

// UpdateACO is a helper method to define mock.On call
//   - ctx context.Context
//   - acoUUID uuid.UUID
//   - fieldsAndValues map[string]interface{}
func (_e *MockRepository_Expecter) UpdateACO(ctx interface{}, acoUUID interface{}, fieldsAndValues interface{}) *MockRepository_UpdateACO_Call {
	return &MockRepository_UpdateACO_Call{Call: _e.mock.On("UpdateACO", ctx, acoUUID, fieldsAndValues)}
}

func (_c *MockRepository_UpdateACO_Call) Run(run func(ctx context.Context, acoUUID uuid.UUID, fieldsAndValues map[string]interface{})) *MockRepository_UpdateACO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 map[string]interface{}
		if args[2] != nil {
			arg2 = args[2].(map[string]interface{})
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_UpdateACO_Call) Return(err error) *MockRepository_UpdateACO_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_UpdateACO_Call) RunAndReturn(run func(ctx context.Context, acoUUID uuid.UUID, fieldsAndValues map[string]interface{}) error) *MockRepository_UpdateACO_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCCLFFileImportStatus provides a mock function for the type MockRepository
func (_mock *MockRepository) UpdateCCLFFileImportStatus(ctx context.Context, fileID uint, importStatus string) error {
	ret := _mock.Called(ctx, fileID, importStatus)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCCLFFileImportStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint, string) error); ok {
		r0 = returnFunc(ctx, fileID, importStatus)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_UpdateCCLFFileImportStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCCLFFileImportStatus'
type MockRepository_UpdateCCLFFileImportStatus_Call struct {
	*mock.Call
}

// UpdateCCLFFileImportStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID uint
//   - importStatus string
func (_e *MockRepository_Expecter) UpdateCCLFFileImportStatus(ctx interface{}, fileID interface{}, importStatus interface{}) *MockRepository_UpdateCCLFFileImportStatus_Call {
	return &MockRepository_UpdateCCLFFileImportStatus_Call{Call: _e.mock.On("UpdateCCLFFileImportStatus", ctx, fileID, importStatus)}
}

func (_c *MockRepository_UpdateCCLFFileImportStatus_Call) Run(run func(ctx context.Context, fileID uint, importStatus string)) *MockRepository_UpdateCCLFFileImportStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint
		if args[1] != nil {
			arg1 = args[1].(uint)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_UpdateCCLFFileImportStatus_Call) Return(err error) *MockRepository_UpdateCCLFFileImportStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_UpdateCCLFFileImportStatus_Call) RunAndReturn(run func(ctx context.Context, fileID uint, importStatus string) error) *MockRepository_UpdateCCLFFileImportStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJob provides a mock function for the type MockRepository
func (_mock *MockRepository) UpdateJob(ctx context.Context, j Job) error {
	ret := _mock.Called(ctx, j)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJob")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, Job) error); ok {
		r0 = returnFunc(ctx, j)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_UpdateJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJob'
type MockRepository_UpdateJob_Call struct {
	*mock.Call
}

// UpdateJob is a helper method to define mock.On call
//   - ctx context.Context
//   - j Job
func (_e *MockRepository_Expecter) UpdateJob(ctx interface{}, j interface{}) *MockRepository_UpdateJob_Call {
	return &MockRepository_UpdateJob_Call{Call: _e.mock.On("UpdateJob", ctx, j)}
}

func (_c *MockRepository_UpdateJob_Call) Run(run func(ctx context.Context, j Job)) *MockRepository_UpdateJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 Job
		if args[1] != nil {
			arg1 = args[1].(Job)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockRepository_UpdateJob_Call) Return(err error) *MockRepository_UpdateJob_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_UpdateJob_Call) RunAndReturn(run func(ctx context.Context, j Job) error) *MockRepository_UpdateJob_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSuppressionFileImportStatus provides a mock function for the type MockRepository
func (_mock *MockRepository) UpdateSuppressionFileImportStatus(ctx context.Context, fileID uint, importStatus string) error {
	ret := _mock.Called(ctx, fileID, importStatus)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSuppressionFileImportStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint, string) error); ok {
		r0 = returnFunc(ctx, fileID, importStatus)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_UpdateSuppressionFileImportStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSuppressionFileImportStatus'
type MockRepository_UpdateSuppressionFileImportStatus_Call struct {
	*mock.Call
}

// UpdateSuppressionFileImportStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - fileID uint
//   - importStatus string
func (_e *MockRepository_Expecter) UpdateSuppressionFileImportStatus(ctx interface{}, fileID interface{}, importStatus interface{}) *MockRepository_UpdateSuppressionFileImportStatus_Call {
	return &MockRepository_UpdateSuppressionFileImportStatus_Call{Call: _e.mock.On("UpdateSuppressionFileImportStatus", ctx, fileID, importStatus)}
}

func (_c *MockRepository_UpdateSuppressionFileImportStatus_Call) Run(run func(ctx context.Context, fileID uint, importStatus string)) *MockRepository_UpdateSuppressionFileImportStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint
		if args[1] != nil {
			arg1 = args[1].(uint)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_UpdateSuppressionFileImportStatus_Call) Return(err error) *MockRepository_UpdateSuppressionFileImportStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_UpdateSuppressionFileImportStatus_Call) RunAndReturn(run func(ctx context.Context, fileID uint, importStatus string) error) *MockRepository_UpdateSuppressionFileImportStatus_Call {
	_c.Call.Return(run)
	return _c
}
